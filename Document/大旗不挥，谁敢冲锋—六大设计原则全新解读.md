## 大旗不挥，谁敢冲锋—六大设计原则全新解读

### 单一责任原则

单一职责原则的英文名称是Single Responsibility Principle，简称是SRP

>只要做过项目，肯定要接触到用户、机构、角色管理这些模块，基本上使用的都是 
>
>RBAC模型（Role-Based Access Control，基于角色的访问控制，通过分配和取消角色来完成 
>
>用户权限的授予和取消，使动作主体（用户）与资源的行为（权限）分离）

把用户的信息抽取成一个BO（Business Object，业务对象），把行为抽取成一个 

Biz（Business Logic，业务逻辑）

**单一职责原则的定义是：应该有且仅有一个原因引起类的变更。**

> **SRP的原话解释是：** 
>
> There should never be more than one reason for a class to change. 

**下单一职责原则有什么好处：** 

● 类的复杂性降低，实现什么职责都有清晰明确的定义； 

● 可读性提高，复杂性降低，那当然可读性提高了； 

● 可维护性提高，可读性提高，那当然更容易维护了； 

● 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修 

改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大 

的帮助。



> ***注意*** 
>
> 单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或 
>
> 类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。

**单一职责适用于接口、类，同时也适用于方法.**

### 里氏替换原则

#### 爱恨纠葛的父子关系 

在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点： 

- 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性； 

-  提高代码的重用性； 

-  子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同； 

- 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的； 

- 提高产品或项目的开放性。 

  自然界的所有事物都是优点和缺点并存的，即使是鸡蛋，有时候也能挑出骨头来，继承的缺点如下： 

  - 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法； 

  - 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约 束；
  - 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。 

Java使用extends关键字来实现继承，它采用了单一继承的规则，C++则采用了多重继承的规则，一个子类可以继承多个父类。从整体上来看，利大于弊，怎么才能让“利”的因素发挥最大的作用，同时减少“弊”带来的麻烦呢？解决方案是引入里氏替换原则（Liskov Substitution Principle，LSP），什么是里氏替换原则呢？它有两种定义： 

- 第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对 象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变 化，那么类型S是类型T的子类型。）
- 第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的 对象。）

**第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且** 

**替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。**





































